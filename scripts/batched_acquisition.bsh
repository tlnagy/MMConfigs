/*  Image positions in batches, i.e. introduce a hierarchy in the position 
 *  list such that each batch of positions is imaged in parallel while batches 
 *  themselves are imaged in series.
 * 
 *  Tamas Nagy, 2019
 * 
 */

import org.micromanager.PositionList;
import org.micromanager.MultiStagePosition;
import org.micromanager.data.Coords;
import org.micromanager.data.Image;
import org.micromanager.data.Datastore;
import org.micromanager.data.Metadata;
import org.micromanager.display.DisplayWindow;
import org.micromanager.acquisition.ChannelSpec;

import java.util.LinkedHashMap;
import java.util.ArrayList;
import java.io.File;

PositionList pl = mm.positions().getPositionList();

LinkedHashMap batchedPos = new LinkedHashMap();

print("Batching positions by well");

//iterate over all the positions and group them by well
for (int p=0; p < pl.getNumberOfPositions(); p++) {
	position = pl.getPosition(p);
	positionDetails = position.getLabel().split("-Site_");

	if (positionDetails.length < 2)
		mm.scripter().message("All positions need to be generated using the HCS plugin");
	
	if (batchedPos.get(positionDetails[0]) == null) {
		List poses = new ArrayList();
		poses.add(position);
		batchedPos.put(positionDetails[0], poses);
	} else {
		batchedPos.get(positionDetails[0]).add(position);
	}
}

// load settings from the acquisition panel
settings = mm.acquisitions().getAcquisitionSettings();

// Derive a new unique filename
loc = new File(settings.root, settings.prefix);
loc = mm.data().getUniqueSaveDirectory(loc.getPath());

// setup image storage
Datastore store = mm.data().createSinglePlaneTIFFSeriesDatastore(loc);
DisplayWindow display = mm.displays().createDisplay(store);
mm.displays().manage(store);

// builders needed for image metadata
Coords.CoordsBuilder coordBuilder = mm.data().getCoordsBuilder();
Metadata.MetadataBuilder mdBuilder = mm.data().getMetadataBuilder();
smdBuilder = mm.data().getSummaryMetadataBuilder();

channels = settings.channels;
groupName = settings.channelGroup;

long interval = (long) settings.intervalMs;

snapManager = mm.live();

batchNum = 0;
// iterate over position batches
for (batch : batchedPos.entrySet()) {
	batchLabel = batch.getKey();
	batchPositions = batch.getValue();
	print("Imaging " + batchLabel);

	// move to the first position in the batch before starting time course
	startPos = batchPositions.get(0);
	MultiStagePosition.goToPosition(startPos, mmc);

	// iterate over time course
	for (int t = 0; t < settings.numFrames; t++) {
		
		long start = System.currentTimeMillis();

		// each position must have a unique index so we offset from the current
		// batch number
		positionNum = batchNum-1;
		// iterate over positions in the position batch
		for (pos : batchPositions) {
			positionNum++;
			posName = pos.getLabel();
			x = pos.getX();
			y = pos.getY();
			print("Imaging position "+posName);
			MultiStagePosition.goToPosition(pos, mmc);

			channelNum = -1;
			// iterate over all the channels
			for (ChannelSpec channel : channels ) {
				if (!channel.useChannel) { continue; }
				++channelNum;
				print(channel.config);
				config = channel.config;
				mmc.setExposure(channel.exposure);
				mmc.setConfig(groupName, config);
				mmc.waitForConfig(groupName, config);
			
				Image image = snapManager.snap(false).get(0);
				metadata = mdBuilder.positionName(posName).xPositionUm(x).yPositionUm(y).build();
				coords = coordBuilder.channel(channelNum).time(t).stagePosition(positionNum).build();
				image = image.copyWith(coords, metadata);
				store.putImage(image);
			}
		
		}

		

		/* 
		 *  WAIT TILL NEXT TIME POINT
		 */
		
		long timediff = interval - (System.currentTimeMillis() - start);
		// do not sleep for last time point
		if (t+1 != settings.numFrames) {
			if (timediff > 0) { 
				Thread.sleep(timediff);
			} else {
				mm.scripter().message("Not enough time to batch images");
			}
		}	
	}
	batchNum += batchPositions.size();
}

store.freeze();